import os
import aiohttp
import json
import base64
from typing import List, Dict, Any, Optional

# Package Imports
from .base import BaseModel
from .types import CompletionResponse
from ..errors import ModelAccessError, NotAVisionModel, MissingEnvironmentVariables
from ..constants.messages import Messages
from ..constants.prompts import Prompts
from ..processor.image import encode_image_to_base64

DEFAULT_SYSTEM_PROMPT = Prompts.DEFAULT_SYSTEM_PROMPT


class CustomAPIModel(BaseModel):
    """Custom API model for calling external vision APIs with custom format."""
    
    _system_prompt = DEFAULT_SYSTEM_PROMPT

    def __init__(
        self,
        model: Optional[str] = None,
        api_url: Optional[str] = None,
        api_key: Optional[str] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs,
    ):
        """
        Initializes the Custom API model interface.
        
        :param model: The model name to use in the API call
        :type model: str, optional
        :param api_url: The API endpoint URL
        :type api_url: str, optional
        :param api_key: The API key for authentication
        :type api_key: str, optional
        :param headers: Additional headers for the API request
        :type headers: Dict[str, str], optional
        :param kwargs: Additional keyword arguments to pass to the API call
        """
        super().__init__(model=model, **kwargs)
        
        self.api_url = api_url
        self.api_key = api_key
        self.headers = headers or {}
        
        # Set default headers
        if self.api_key:
            self.headers["Authorization"] = f"Bearer {self.api_key}"
        
        self.headers.setdefault("Content-Type", "application/json")
        
        # Validate required parameters
        self.validate_required_params()

    @property
    def system_prompt(self) -> str:
        '''Returns the system prompt for the model.'''
        return self._system_prompt
    
    @system_prompt.setter
    def system_prompt(self, prompt: str) -> None:
        '''
        Sets/overrides the system prompt for the model.
        '''
        self._system_prompt = prompt

    def validate_required_params(self) -> None:
        """Validates that required parameters are provided."""
        if not self.api_url:
            raise MissingEnvironmentVariables(
                extra_info={"message": "api_url is required for CustomAPIModel"}
            )
        
        if not self.model:
            raise MissingEnvironmentVariables(
                extra_info={"message": "model is required for CustomAPIModel"}
            )

    def validate_model(self) -> None:
        """Validates the model - for custom API, we assume it's a vision model."""
        # For custom API, we assume the user knows what they're doing
        pass

    def validate_access(self) -> None:
        """Validates access to the model."""
        # For custom API, we can't validate without making a request
        # This will be handled during the actual API call
        pass

    async def completion(
        self,
        image_path: str,
        maintain_format: bool,
        prior_page: str,
    ) -> CompletionResponse:
        """Custom API completion for image to markdown conversion.

        :param image_path: Path to the image file.
        :type image_path: str
        :param maintain_format: Whether to maintain the format from the previous page.
        :type maintain_format: bool
        :param prior_page: The markdown content of the previous page.
        :type prior_page: str

        :return: The markdown content generated by the model.
        """
        messages = await self._prepare_messages(
            image_path=image_path,
            maintain_format=maintain_format,
            prior_page=prior_page,
        )

        payload = {
            "model": self.model,
            "stream": False,
            "messages": messages,
            "max_tokens": 400
        }
        
        # Add any additional parameters from kwargs
        payload.update(self.kwargs)

        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    self.api_url,
                    headers=self.headers,
                    data=json.dumps(payload)
                ) as response:
                    if response.status != 200:
                        error_text = await response.text()
                        raise Exception(f"API request failed with status {response.status}: {error_text}")
                    
                    response_data = await response.json()
                    
                    # Extract content and token usage from response
                    content = response_data["choices"][0]["message"]["content"]
                    
                    # Try to extract token usage, with fallback values
                    usage = response_data.get("usage", {})
                    input_tokens = usage.get("prompt_tokens", 0)
                    output_tokens = usage.get("completion_tokens", 0)
                    
                    return CompletionResponse(
                        content=content,
                        input_tokens=input_tokens,
                        output_tokens=output_tokens,
                    )
        
        except Exception as err:
            raise Exception(Messages.COMPLETION_ERROR.format(err))

    async def _prepare_messages(
        self,
        image_path: str,
        maintain_format: bool,
        prior_page: str,
    ) -> List[Dict[str, Any]]:
        """Prepares the messages to send to the Custom API.

        :param image_path: Path to the image file.
        :type image_path: str
        :param maintain_format: Whether to maintain the format from the previous page.
        :type maintain_format: bool
        :param prior_page: The markdown content of the previous page.
        :type prior_page: str
        """
        # Encode image to base64
        base64_image = await encode_image_to_base64(image_path)
        
        # Prepare user content
        content = [
            {
                "type": "text",
                "text": "这张图片有什么"  # Default text, can be customized
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": f"data:image/png;base64,{base64_image}"
                }
            }
        ]

        # If content has already been generated, add it to context.
        if maintain_format and prior_page:
            content[0]["text"] = f"请分析这张图片，并保持与之前页面一致的格式。之前的页面内容：\n\n{prior_page}\n\n现在请分析这张图片："

        messages = [
            {
                "role": "user",
                "content": content
            }
        ]

        return messages
